//! SP1 Guest Program: EVM Transaction Verification Circuit
//!
//! This program runs INSIDE the SP1 STARK prover. It verifies:
//!
//! 1. Block header hash matches claimed block hash
//! 2. Transaction is included in the block (Merkle-Patricia Trie proof)
//! 3. Transaction receipt is included in the block (MPT proof)
//! 4. Transaction was successful (receipt.status == 1)
//! 5. Extracts and commits relevant event logs
//!
//! The proof generated by this program proves all of the above without
//! revealing the full block header, transaction, or receipt data to the
//! on-chain verifier.
//!
//! # Security Model
//!
//! - Block hash provides the root of trust (can be validated against an oracle)
//! - Transaction MPT proof proves inclusion in the block
//! - Receipt MPT proof proves execution result
//! - Event logs prove specific contract interactions (e.g., USDC lock)
//!
//! # Compute Cost
//!
//! Guest execution is off-chain and free. The on-chain verification of the
//! resulting STARK proof costs ~500k compute units on Solana.

#![no_main]
sp1_zkvm::entrypoint!(main);

use tiny_keccak::{Hasher, Keccak};
use x0_sp1_common::{EVMProofPublicInputs, EVMProofWitness, EventLog};

pub fn main() {
    // ========================================================================
    // Step 1: Read private inputs (witness)
    // ========================================================================

    let witness: EVMProofWitness = sp1_zkvm::io::read();

    // ========================================================================
    // Step 2: Verify block header hash
    //
    // The block header is RLP-encoded. We keccak256 it and verify
    // it matches the claimed block hash.
    // ========================================================================

    let computed_block_hash = keccak256(&witness.block_header_rlp);
    assert_eq!(
        computed_block_hash,
        witness.block_hash,
        "Block header hash mismatch: computed vs claimed"
    );

    // ========================================================================
    // Step 3: Extract roots from block header
    //
    // RLP block header structure (relevant fields):
    //   [0]  parentHash
    //   [1]  ommersHash
    //   [2]  beneficiary
    //   [3]  stateRoot
    //   [4]  transactionsRoot  ← we need this
    //   [5]  receiptsRoot      ← we need this
    //   ...
    // ========================================================================

    let header_items = rlp_decode_list(&witness.block_header_rlp);

    // Extract transactionsRoot (field index 4)
    assert!(
        header_items.len() > 5,
        "Block header has too few fields"
    );
    let transactions_root = extract_bytes32(&header_items[4]);

    // Extract receiptsRoot (field index 5)
    let receipts_root = extract_bytes32(&header_items[5]);

    // ========================================================================
    // Step 4: Verify transaction inclusion (MPT proof)
    //
    // Prove that the transaction exists in the block's transaction trie.
    // The key is the RLP-encoded transaction index.
    // ========================================================================

    let tx_key = rlp_encode_u32(witness.transaction_index);
    let tx_leaf_hash = keccak256(&witness.transaction_rlp);

    assert!(
        verify_mpt_proof(
            &transactions_root,
            &tx_key,
            &witness.transaction_rlp,
            &witness.tx_proof_nodes,
        ),
        "Transaction MPT proof verification failed"
    );

    // ========================================================================
    // Step 5: Verify receipt inclusion (MPT proof)
    //
    // Prove that the receipt exists in the block's receipt trie.
    // The key is the same RLP-encoded transaction index.
    // ========================================================================

    assert!(
        verify_mpt_proof(
            &receipts_root,
            &tx_key,
            &witness.receipt_rlp,
            &witness.receipt_proof_nodes,
        ),
        "Receipt MPT proof verification failed"
    );

    // ========================================================================
    // Step 6: Parse receipt and verify success
    // ========================================================================

    let receipt_items = rlp_decode_list(&witness.receipt_rlp);

    // For Type 2 (EIP-1559) transactions, the receipt is prefixed with 0x02
    // We handle both legacy and typed receipts
    let (status, logs_rlp) = parse_receipt(&witness.receipt_rlp);

    assert_eq!(status, 1, "Transaction receipt status is not success");

    // ========================================================================
    // Step 7: Extract event logs
    // ========================================================================

    let event_logs = extract_event_logs(&logs_rlp);

    // ========================================================================
    // Step 8: Commit public outputs
    //
    // These values will be available to the Solana verifier after proof
    // verification. They are cryptographically bound to the proof.
    // ========================================================================

    let public_inputs = EVMProofPublicInputs {
        block_hash: witness.block_hash,
        block_number: witness.block_number,
        tx_hash: keccak256(&witness.transaction_rlp),
        from: witness.from,
        to: witness.to,
        value: witness.value,
        success: true,
        event_logs,
    };

    // Borsh-serialize for Solana compatibility
    let serialized = borsh::to_vec(&public_inputs)
        .expect("Failed to serialize public inputs");

    sp1_zkvm::io::commit_slice(&serialized);
}

// ============================================================================
// Cryptographic Helpers
// ============================================================================

/// Compute keccak256 hash
fn keccak256(data: &[u8]) -> [u8; 32] {
    let mut hasher = Keccak::v256();
    let mut output = [0u8; 32];
    hasher.update(data);
    hasher.finalize(&mut output);
    output
}

// ============================================================================
// RLP Helpers
// ============================================================================

/// Decode an RLP list into its items (raw byte slices)
///
/// Returns the byte ranges of each item in the list.
fn rlp_decode_list(data: &[u8]) -> Vec<&[u8]> {
    let mut items = Vec::new();
    let mut pos = 0;

    if data.is_empty() {
        return items;
    }

    // Check for typed transaction/receipt prefix (0x01, 0x02, 0x03)
    let start = if data[0] <= 0x03 {
        1 // Skip type byte
    } else {
        0
    };

    // Decode list header
    let (list_data, _) = decode_rlp_item(&data[start..]);

    let mut inner_pos = 0;
    while inner_pos < list_data.len() {
        let (item, consumed) = decode_rlp_item(&list_data[inner_pos..]);
        items.push(item);
        inner_pos += consumed;
    }

    items
}

/// Decode a single RLP item, returning the data and total bytes consumed
fn decode_rlp_item(data: &[u8]) -> (&[u8], usize) {
    if data.is_empty() {
        return (&[], 0);
    }

    let prefix = data[0];

    if prefix < 0x80 {
        // Single byte
        (&data[0..1], 1)
    } else if prefix <= 0xb7 {
        // Short string (0-55 bytes)
        let len = (prefix - 0x80) as usize;
        (&data[1..1 + len], 1 + len)
    } else if prefix <= 0xbf {
        // Long string
        let len_bytes = (prefix - 0xb7) as usize;
        let len = decode_length(&data[1..1 + len_bytes]);
        (&data[1 + len_bytes..1 + len_bytes + len], 1 + len_bytes + len)
    } else if prefix <= 0xf7 {
        // Short list (0-55 bytes total)
        let len = (prefix - 0xc0) as usize;
        (&data[1..1 + len], 1 + len)
    } else {
        // Long list
        let len_bytes = (prefix - 0xf7) as usize;
        let len = decode_length(&data[1..1 + len_bytes]);
        (&data[1 + len_bytes..1 + len_bytes + len], 1 + len_bytes + len)
    }
}

/// Decode a big-endian length from bytes
fn decode_length(data: &[u8]) -> usize {
    let mut length = 0usize;
    for &byte in data {
        length = (length << 8) | (byte as usize);
    }
    length
}

/// Extract a 32-byte value from an RLP-decoded item
fn extract_bytes32(data: &[u8]) -> [u8; 32] {
    let mut result = [0u8; 32];
    if data.len() >= 32 {
        result.copy_from_slice(&data[..32]);
    } else {
        // Left-pad with zeros for shorter values
        let offset = 32 - data.len();
        result[offset..].copy_from_slice(data);
    }
    result
}

/// RLP-encode a u32 (for transaction index key)
fn rlp_encode_u32(value: u32) -> Vec<u8> {
    if value == 0 {
        return vec![0x80]; // RLP empty string
    }
    let bytes = value.to_be_bytes();
    let start = bytes.iter().position(|&b| b != 0).unwrap_or(3);
    let significant = &bytes[start..];

    if significant.len() == 1 && significant[0] < 0x80 {
        significant.to_vec()
    } else {
        let mut encoded = vec![0x80 + significant.len() as u8];
        encoded.extend_from_slice(significant);
        encoded
    }
}

// ============================================================================
// Merkle-Patricia Trie (MPT) Proof Verification
// ============================================================================

/// Verify a Merkle-Patricia Trie proof
///
/// Proves that a key-value pair exists in a trie with the given root hash.
///
/// # Arguments
/// * `root` - Expected trie root hash (from block header)
/// * `key` - RLP-encoded key (transaction index)
/// * `value` - Expected value (RLP-encoded transaction or receipt)
/// * `proof_nodes` - Trie nodes from root to leaf
fn verify_mpt_proof(
    root: &[u8; 32],
    key: &[u8],
    value: &[u8],
    proof_nodes: &[Vec<u8>],
) -> bool {
    if proof_nodes.is_empty() {
        return false;
    }

    // Verify the root node hash matches
    let first_node_hash = keccak256(&proof_nodes[0]);
    if first_node_hash != *root {
        return false;
    }

    // Convert key to nibbles for trie traversal
    let key_nibbles = bytes_to_nibbles(key);
    let mut key_pos = 0;

    for (i, node) in proof_nodes.iter().enumerate() {
        let items = rlp_decode_list(node);
        let is_last = i == proof_nodes.len() - 1;

        match items.len() {
            17 => {
                // Branch node: 16 children + value
                if is_last {
                    // Value should be at the branch's value slot
                    if key_pos == key_nibbles.len() {
                        return items[16] == value;
                    }
                } else if key_pos < key_nibbles.len() {
                    // Follow the child at the current nibble
                    let nibble = key_nibbles[key_pos] as usize;
                    let child = items[nibble];

                    // Verify next node hash
                    if i + 1 < proof_nodes.len() {
                        let child_hash = if child.len() < 32 {
                            // Inline node
                            keccak256(child)
                        } else {
                            let mut h = [0u8; 32];
                            h.copy_from_slice(child);
                            h
                        };
                        let next_hash = keccak256(&proof_nodes[i + 1]);
                        if child_hash != next_hash {
                            return false;
                        }
                    }
                    key_pos += 1;
                }
            }
            2 => {
                // Extension or Leaf node
                let path = decode_compact_path(items[0]);
                let is_leaf = path.0;
                let nibbles = path.1;

                // Verify path matches
                if key_pos + nibbles.len() > key_nibbles.len() {
                    return false;
                }
                if key_nibbles[key_pos..key_pos + nibbles.len()] != nibbles[..] {
                    return false;
                }
                key_pos += nibbles.len();

                if is_leaf && is_last {
                    // Leaf node: value should match
                    return items[1] == value;
                } else if !is_leaf && !is_last {
                    // Extension node: verify next node hash
                    if i + 1 < proof_nodes.len() {
                        let child_hash = if items[1].len() == 32 {
                            let mut h = [0u8; 32];
                            h.copy_from_slice(items[1]);
                            h
                        } else {
                            keccak256(items[1])
                        };
                        let next_hash = keccak256(&proof_nodes[i + 1]);
                        if child_hash != next_hash {
                            return false;
                        }
                    }
                }
            }
            _ => return false,
        }
    }

    true
}

/// Convert bytes to nibbles (each byte → 2 nibbles)
fn bytes_to_nibbles(data: &[u8]) -> Vec<u8> {
    let mut nibbles = Vec::with_capacity(data.len() * 2);
    for &byte in data {
        nibbles.push(byte >> 4);
        nibbles.push(byte & 0x0f);
    }
    nibbles
}

/// Decode compact (hex prefix) encoded path
/// Returns (is_leaf, nibbles)
fn decode_compact_path(data: &[u8]) -> (bool, Vec<u8>) {
    if data.is_empty() {
        return (false, Vec::new());
    }

    let first = data[0];
    let is_leaf = first >= 0x20;
    let has_odd_length = (first & 0x10) != 0;

    let mut nibbles = Vec::new();

    if has_odd_length {
        nibbles.push(first & 0x0f);
    }

    for &byte in &data[1..] {
        nibbles.push(byte >> 4);
        nibbles.push(byte & 0x0f);
    }

    (is_leaf, nibbles)
}

// ============================================================================
// Receipt Parsing
// ============================================================================

/// Parse a transaction receipt, handling both legacy and typed receipts
///
/// Returns (status, logs_rlp_bytes)
fn parse_receipt(receipt_rlp: &[u8]) -> (u8, Vec<u8>) {
    let data = if !receipt_rlp.is_empty() && receipt_rlp[0] <= 0x03 {
        // Typed receipt: skip type byte
        &receipt_rlp[1..]
    } else {
        receipt_rlp
    };

    let items = rlp_decode_list(data);

    // Receipt fields:
    //   [0] status (post-Byzantium) or state root (pre-Byzantium)
    //   [1] cumulativeGasUsed
    //   [2] logsBloom
    //   [3] logs

    if items.len() < 4 {
        return (0, Vec::new());
    }

    let status = if items[0].len() == 1 {
        items[0][0]
    } else if items[0].is_empty() {
        0
    } else {
        // Pre-Byzantium: state root (32 bytes) = success
        1
    };

    (status, items[3].to_vec())
}

/// Extract event logs from the RLP-encoded logs list
fn extract_event_logs(logs_rlp: &[u8]) -> Vec<EventLog> {
    let log_items = rlp_decode_list(logs_rlp);
    let mut events = Vec::new();

    for log_rlp in log_items {
        let log_fields = rlp_decode_list(log_rlp);
        if log_fields.len() < 3 {
            continue;
        }

        // Log fields: [address, topics, data]
        let mut contract_address = [0u8; 20];
        if log_fields[0].len() >= 20 {
            contract_address.copy_from_slice(&log_fields[0][..20]);
        }

        let topic_items = rlp_decode_list(log_fields[1]);
        let topics: Vec<[u8; 32]> = topic_items
            .iter()
            .map(|t| extract_bytes32(t))
            .collect();

        events.push(EventLog {
            contract_address,
            topics,
            data: log_fields[2].to_vec(),
        });
    }

    events
}
