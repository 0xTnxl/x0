/**
 * WASM-based zero-knowledge proof generation for confidential transfers
 *
 * This module provides TypeScript bindings to Rust-implemented Groth16 proofs
 * compiled to WebAssembly. It replaces placeholder proof generation with
 * cryptographically secure proofs that can be verified on-chain.
 *
 * @module zk-wasm
 */

/**
 * WASM module interface (generated by wasm-pack)
 */
interface WasmProofs {
  generate_pubkey_validity_proof(keypairBytes: Uint8Array): Uint8Array;

  generate_withdraw_proof(
    keypairBytes: Uint8Array,
    balanceCiphertext: Uint8Array,
    amount: bigint
  ): {
    proofData: Uint8Array;
    newBalance: number;
  };

  generate_zero_balance_proof(
    keypairBytes: Uint8Array,
    balanceCiphertext: Uint8Array
  ): Uint8Array;

  decrypt_elgamal_u64(
    keypairBytes: Uint8Array,
    ciphertext: Uint8Array
  ): bigint;

  version(): string;
}

/**
 * Cached WASM module instance (lazy loaded)
 */
let wasmModule: WasmProofs | null = null;

/**
 * Environment detection
 */
function detectEnvironment(): "node" | "web" {
  if (
    typeof process !== "undefined" &&
    process.versions &&
    process.versions.node
  ) {
    return "node";
  }
  return "web";
}

/**
 * Load the WASM module for the current environment
 */
async function loadWasmModule(): Promise<WasmProofs> {
  const env = detectEnvironment();

  if (env === "node") {
    try {
      const wasm = await import("../wasm/nodejs/x0_zk_proofs.js");
      return wasm as unknown as WasmProofs;
    } catch (error) {
      throw new Error(
        `Failed to load WASM module for Node.js: ${error}. ` +
          `Did you run "npm run build:wasm"?`
      );
    }
  } else {
    try {
      const wasm = await import("../wasm/web/x0_zk_proofs.js");
      await (wasm as any).default();
      return wasm as unknown as WasmProofs;
    } catch (error) {
      throw new Error(
        `Failed to load WASM module for web: ${error}. ` +
          `Did you run "npm run build:wasm"?`
      );
    }
  }
}

/**
 * Initialize the WASM module (call once before using proof functions)
 *
 * Called automatically by proof generation functions, but can be called
 * manually for better control over initialization timing.
 */
export async function initWasm(): Promise<void> {
  if (!wasmModule) {
    wasmModule = await loadWasmModule();
  }
}

/**
 * Get the WASM module version
 */
export async function getWasmVersion(): Promise<string> {
  await initWasm();
  return wasmModule!.version();
}

/**
 * Concatenate ElGamal secret key and public key into 64-byte keypair format
 */
function buildKeypairBytes(
  secretKey: Uint8Array,
  pubkey: Uint8Array
): Uint8Array {
  const keypair = new Uint8Array(64);
  keypair.set(secretKey, 0);
  keypair.set(pubkey, 32);
  return keypair;
}

/**
 * Generate PubkeyValidityProof using WASM
 *
 * @param secretKey - 32-byte ElGamal secret key
 * @param pubkey - 32-byte ElGamal public key
 * @returns Serialized PubkeyValidityData proof bytes
 */
export async function generatePubkeyValidityProofWasm(
  secretKey: Uint8Array,
  pubkey: Uint8Array
): Promise<Uint8Array> {
  await initWasm();

  try {
    const keypairBytes = buildKeypairBytes(secretKey, pubkey);
    return wasmModule!.generate_pubkey_validity_proof(keypairBytes);
  } catch (error) {
    throw new Error(`PubkeyValidityProof generation failed: ${error}`);
  }
}

/**
 * Generate WithdrawProof using WASM
 *
 * The WASM module generates the Groth16 proof and computes the new balance.
 * The caller is responsible for encrypting the new balance with AE key.
 *
 * @param balanceCiphertext - 64-byte ElGamal ciphertext of current balance
 * @param amount - Amount to withdraw
 * @param secretKey - 32-byte ElGamal secret key
 * @param pubkey - 32-byte ElGamal public key
 * @returns Object with proofData bytes and newBalance
 */
export async function generateWithdrawProofWasm(
  balanceCiphertext: Uint8Array,
  amount: bigint,
  secretKey: Uint8Array,
  pubkey: Uint8Array
): Promise<{
  proofData: Uint8Array;
  newBalance: bigint;
}> {
  await initWasm();

  try {
    const keypairBytes = buildKeypairBytes(secretKey, pubkey);
    const result = wasmModule!.generate_withdraw_proof(
      keypairBytes,
      balanceCiphertext,
      amount
    );
    return {
      proofData: result.proofData,
      newBalance: BigInt(result.newBalance),
    };
  } catch (error) {
    throw new Error(`WithdrawProof generation failed: ${error}`);
  }
}

/**
 * Generate ZeroBalanceProof using WASM
 *
 * @param balanceCiphertext - 64-byte ElGamal ciphertext of current balance
 * @param secretKey - 32-byte ElGamal secret key
 * @param pubkey - 32-byte ElGamal public key
 * @returns Serialized ZeroBalanceProofData proof bytes
 */
export async function generateZeroBalanceProofWasm(
  balanceCiphertext: Uint8Array,
  secretKey: Uint8Array,
  pubkey: Uint8Array
): Promise<Uint8Array> {
  await initWasm();

  try {
    const keypairBytes = buildKeypairBytes(secretKey, pubkey);
    return wasmModule!.generate_zero_balance_proof(
      keypairBytes,
      balanceCiphertext
    );
  } catch (error) {
    throw new Error(`ZeroBalanceProof generation failed: ${error}`);
  }
}

/**
 * Decrypt an ElGamal ciphertext to u64 using WASM
 *
 * This is used for decrypting pending balance lo/hi parts in confidential transfers.
 * Token-2022 splits large amounts into low and high parts (lo + hi * 2^16).
 *
 * @param ciphertext - 64-byte ElGamal ciphertext
 * @param secretKey - 32-byte ElGamal secret key
 * @param pubkey - 32-byte ElGamal public key
 * @returns Decrypted u64 value as BigInt
 */
export async function decryptElGamalU64Wasm(
  ciphertext: Uint8Array,
  secretKey: Uint8Array,
  pubkey: Uint8Array
): Promise<bigint> {
  await initWasm();

  try {
    const keypairBytes = buildKeypairBytes(secretKey, pubkey);
    return wasmModule!.decrypt_elgamal_u64(keypairBytes, ciphertext);
  } catch (error) {
    throw new Error(`ElGamal decryption failed: ${error}`);
  }
}
