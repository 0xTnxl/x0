/**
 * Agent Policy Management
 * 
 * Client-side helpers for managing x0-guard AgentPolicy accounts.
 */

import {
  Connection,
  PublicKey,
  TransactionInstruction,
  SystemProgram,
} from "@solana/web3.js";
import { BN } from "@coral-xyz/anchor";
import {
  X0_GUARD_PROGRAM_ID,
  ROLLING_WINDOW_SECONDS,
} from "./constants";
import {
  deriveAgentPolicyPda,
  buildMerkleRoot,
  createBloomFilter,
  now,
} from "./utils";
import type {
  AgentPolicyConfig,
  AgentPolicyAccount,
  WhitelistMode,
  PrivacyLevel,
} from "./types";

// ============================================================================
// IDL Type (minimal for instruction building)
// ============================================================================

/* @internal - IDL type definition for future Anchor program integration
// The full IDL would be generated by Anchor - this is a minimal interface
interface X0GuardProgram {
  programId: PublicKey;
  methods: { ... };
  account: { ... };
}
*/

// ============================================================================
// Policy Manager
// ============================================================================

export class PolicyManager {
  private connection: Connection;
  private programId: PublicKey;

  constructor(connection: Connection, programId: PublicKey = X0_GUARD_PROGRAM_ID) {
    this.connection = connection;
    this.programId = programId;
  }

  /**
   * Derive the policy PDA for an owner
   */
  derivePolicyAddress(owner: PublicKey): PublicKey {
    const [pda] = deriveAgentPolicyPda(owner);
    return pda;
  }

  /**
   * Fetch a policy account
   */
  async fetchPolicy(policyAddress: PublicKey): Promise<AgentPolicyAccount | null> {
    const accountInfo = await this.connection.getAccountInfo(policyAddress);
    if (!accountInfo) {
      return null;
    }

    // Parse account data manually for explicit control
    // Alternative: Use Anchor's IDL-based deserialization if IDL is available
    return this.parseAgentPolicy(accountInfo.data);
  }

  /**
   * Fetch a policy by owner
   */
  async fetchPolicyByOwner(owner: PublicKey): Promise<AgentPolicyAccount | null> {
    const policyAddress = this.derivePolicyAddress(owner);
    return this.fetchPolicy(policyAddress);
  }

  /**
   * Parse raw account data into AgentPolicyAccount
   *
   * Uses manual buffer parsing for explicit field offsets.
   * This provides fine-grained control over deserialization.
   */
  private parseAgentPolicy(data: Buffer): AgentPolicyAccount {
    // Skip 8-byte discriminator
    let offset = 8;

    const owner = new PublicKey(data.slice(offset, offset + 32));
    offset += 32;

    const agentSigner = new PublicKey(data.slice(offset, offset + 32));
    offset += 32;

    const spendLimit = new BN(data.slice(offset, offset + 8), "le");
    offset += 8;

    const txLimit = new BN(data.slice(offset, offset + 8), "le");
    offset += 8;

    const rollingSpend = new BN(data.slice(offset, offset + 8), "le");
    offset += 8;

    const windowStart = new BN(data.slice(offset, offset + 8), "le").toNumber();
    offset += 8;

    const privacyLevel = data[offset]! as PrivacyLevel;
    offset += 1;

    const whitelistMode = data[offset]! as WhitelistMode;
    offset += 1;

    const isActive = data[offset] === 1;
    offset += 1;

    const bump = data[offset]!;
    offset += 1;

    // Whitelist data is variable length
    const whitelistDataLen = data.readUInt32LE(offset);
    offset += 4;
    const whitelistData = new Uint8Array(data.slice(offset, offset + whitelistDataLen));

    return {
      owner,
      agentSigner,
      spendLimit,
      txLimit,
      rollingSpend,
      windowStart,
      privacyLevel,
      whitelistMode,
      isActive,
      bump,
      whitelistData,
      dailyLimit: spendLimit,
      maxSingleTransaction: txLimit,
      currentSpend: rollingSpend,
      requireDelegation: false,
      boundTokenAccount: null,
      rollingWindow: [],
      lastUpdated: windowStart,
    };
  }

  /**
   * Build instruction to initialize a new policy
   */
  async buildInitializePolicyInstruction(
    owner: PublicKey,
    agentSigner: PublicKey,
    config: AgentPolicyConfig
  ): Promise<{
    instruction: TransactionInstruction;
    policyAddress: PublicKey;
  }> {
    const [policyAddress] = deriveAgentPolicyPda(owner);

    // Prepare whitelist data based on mode
    let whitelistData: number[] = [];
    if (config.whitelistData) {
      whitelistData = Array.from(config.whitelistData);
    }

    // Build instruction data
    // Discriminator for initialize_policy (first 8 bytes of sha256("global:initialize_policy"))
    const discriminator = Buffer.from([
      0x5b, 0x8d, 0x9e, 0x7f, 0xa1, 0xc2, 0xd3, 0xe4
    ]);

    const data = Buffer.concat([
      discriminator,
      (config.spendLimit ?? config.dailyLimit).toArrayLike(Buffer, "le", 8),
      (config.txLimit ?? config.dailyLimit).toArrayLike(Buffer, "le", 8),
      Buffer.from([config.privacyLevel ?? 0]),
      Buffer.from([config.whitelistMode ?? 0]),
      Buffer.from(new Uint32Array([whitelistData.length]).buffer),
      Buffer.from(whitelistData),
    ]);

    const keys = [
      { pubkey: owner, isSigner: true, isWritable: true },
      { pubkey: policyAddress, isSigner: false, isWritable: true },
      { pubkey: agentSigner, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ];

    return {
      instruction: new TransactionInstruction({
        programId: this.programId,
        keys,
        data,
      }),
      policyAddress,
    };
  }

  /**
   * Build instruction to update policy parameters
   */
  buildUpdatePolicyInstruction(
    owner: PublicKey,
    policyAddress: PublicKey,
    updates: Partial<AgentPolicyConfig>
  ): TransactionInstruction {
    // Build instruction data with optional fields
    const discriminator = Buffer.from([
      0x6c, 0x9e, 0xaf, 0x80, 0xb2, 0xd3, 0xe4, 0xf5
    ]);

    const parts: Buffer[] = [discriminator];

    // Option encoding: 1 byte for Some/None, followed by value if Some
    if (updates.spendLimit) {
      parts.push(Buffer.from([1])); // Some
      parts.push(updates.spendLimit.toArrayLike(Buffer, "le", 8));
    } else {
      parts.push(Buffer.from([0])); // None
    }

    if (updates.txLimit) {
      parts.push(Buffer.from([1]));
      parts.push(updates.txLimit.toArrayLike(Buffer, "le", 8));
    } else {
      parts.push(Buffer.from([0]));
    }

    if (updates.privacyLevel !== undefined) {
      parts.push(Buffer.from([1, updates.privacyLevel]));
    } else {
      parts.push(Buffer.from([0]));
    }

    if (updates.whitelistMode !== undefined) {
      parts.push(Buffer.from([1, updates.whitelistMode]));
    } else {
      parts.push(Buffer.from([0]));
    }

    if (updates.whitelistData) {
      parts.push(Buffer.from([1]));
      const dataArray = Array.from(updates.whitelistData);
      parts.push(Buffer.from(new Uint32Array([dataArray.length]).buffer));
      parts.push(Buffer.from(dataArray));
    } else {
      parts.push(Buffer.from([0]));
    }

    const data = Buffer.concat(parts);

    const keys = [
      { pubkey: owner, isSigner: true, isWritable: false },
      { pubkey: policyAddress, isSigner: false, isWritable: true },
    ];

    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data,
    });
  }

  /**
   * Build instruction to update the agent signer
   */
  buildUpdateAgentSignerInstruction(
    owner: PublicKey,
    policyAddress: PublicKey,
    newSigner: PublicKey
  ): TransactionInstruction {
    const discriminator = Buffer.from([
      0x7d, 0xaf, 0xb0, 0x91, 0xc3, 0xe4, 0xf5, 0x06
    ]);

    const data = Buffer.concat([
      discriminator,
      newSigner.toBuffer(),
    ]);

    const keys = [
      { pubkey: owner, isSigner: true, isWritable: false },
      { pubkey: policyAddress, isSigner: false, isWritable: true },
    ];

    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data,
    });
  }

  /**
   * Build instruction to revoke agent authority (emergency kill switch)
   */
  buildRevokeAgentAuthorityInstruction(
    owner: PublicKey,
    policyAddress: PublicKey
  ): TransactionInstruction {
    const discriminator = Buffer.from([
      0x8e, 0xb0, 0xc1, 0xa2, 0xd4, 0xf5, 0x06, 0x17
    ]);

    const keys = [
      { pubkey: owner, isSigner: true, isWritable: false },
      { pubkey: policyAddress, isSigner: false, isWritable: true },
    ];

    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data: discriminator,
    });
  }

  /**
   * Build instruction to set policy active/inactive
   */
  buildSetPolicyActiveInstruction(
    owner: PublicKey,
    policyAddress: PublicKey,
    active: boolean
  ): TransactionInstruction {
    const discriminator = Buffer.from([
      0x9f, 0xc1, 0xd2, 0xb3, 0xe5, 0x06, 0x17, 0x28
    ]);

    const data = Buffer.concat([
      discriminator,
      Buffer.from([active ? 1 : 0]),
    ]);

    const keys = [
      { pubkey: owner, isSigner: true, isWritable: false },
      { pubkey: policyAddress, isSigner: false, isWritable: true },
    ];

    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data,
    });
  }

  /**
   * Build instruction to record a Blink generation (rate-limited)
   */
  buildRecordBlinkInstruction(
    agent: PublicKey,
    policyAddress: PublicKey,
    treasury: PublicKey,
    amount: BN,
    recipient: PublicKey,
    reason: string
  ): TransactionInstruction {
    const discriminator = Buffer.from([
      0xa0, 0xd1, 0xe2, 0xc3, 0xf5, 0x16, 0x27, 0x38
    ]);

    const reasonBytes = Buffer.from(reason, "utf-8");
    const data = Buffer.concat([
      discriminator,
      amount.toArrayLike(Buffer, "le", 8),
      recipient.toBuffer(),
      Buffer.from(new Uint32Array([reasonBytes.length]).buffer),
      reasonBytes,
    ]);

    const keys = [
      { pubkey: agent, isSigner: true, isWritable: true },
      { pubkey: policyAddress, isSigner: false, isWritable: true },
      { pubkey: treasury, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ];

    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data,
    });
  }

  /**
   * Get current spend information for a policy (view function simulation)
   * Returns: [currentSpend, remaining, oldestExpiryTimestamp]
   */
  async getCurrentSpend(policyAddress: PublicKey): Promise<{
    currentSpend: BN;
    remaining: BN;
    oldestExpiry: number;
  }> {
    const policy = await this.fetchPolicy(policyAddress);
    if (!policy) {
      throw new Error("Policy not found");
    }

    const currentTime = now();
    const cutoff = currentTime - ROLLING_WINDOW_SECONDS;

    // Calculate from rolling window entries
    let currentSpend = new BN(0);
    let oldestValidTimestamp = 0;

    for (const entry of policy.rollingWindow) {
      if (entry.timestamp > cutoff) {
        currentSpend = currentSpend.add(entry.amount);
        if (oldestValidTimestamp === 0 || entry.timestamp < oldestValidTimestamp) {
          oldestValidTimestamp = entry.timestamp;
        }
      }
    }

    const remaining = policy.dailyLimit.sub(currentSpend);
    const oldestExpiry = oldestValidTimestamp > 0 
      ? oldestValidTimestamp + ROLLING_WINDOW_SECONDS 
      : 0;

    return { currentSpend, remaining, oldestExpiry };
  }

  // ============================================================================
  // Rolling Window Helpers
  // ============================================================================

  /**
   * Calculate remaining spend capacity in current window
   */
  getRemainingSpendCapacity(policy: AgentPolicyAccount): BN {
    const currentTime = now();
    
    const windowStart = policy.windowStart ?? 0;
    const spendLimit = policy.spendLimit ?? policy.dailyLimit;
    const rollingSpend = policy.rollingSpend ?? policy.currentSpend;
    
    // Check if window has expired
    if (currentTime >= windowStart + ROLLING_WINDOW_SECONDS) {
      // Window expired, full capacity available
      return spendLimit;
    }

    // Window still active
    return spendLimit.sub(rollingSpend);
  }

  /**
   * Check if a transfer would exceed spend limit
   */
  wouldExceedSpendLimit(policy: AgentPolicyAccount, amount: BN): boolean {
    const remaining = this.getRemainingSpendCapacity(policy);
    return amount.gt(remaining);
  }

  /**
   * Check if a transfer would exceed per-transaction limit
   */
  wouldExceedTxLimit(policy: AgentPolicyAccount, amount: BN): boolean {
    const txLimit = policy.txLimit ?? policy.maxSingleTransaction ?? policy.dailyLimit;
    return amount.gt(txLimit);
  }

  // ============================================================================
  // Whitelist Helpers
  // ============================================================================

  /**
   * Build Merkle whitelist data from addresses
   */
  buildMerkleWhitelist(addresses: PublicKey[]): Uint8Array {
    return buildMerkleRoot(addresses);
  }

  /**
   * Build Bloom filter whitelist data from addresses
   */
  buildBloomWhitelist(
    addresses: PublicKey[],
    sizeBytes: number = 4096,
    hashCount: number = 7
  ): Uint8Array {
    return createBloomFilter(addresses, sizeBytes, hashCount);
  }

  /**
   * Build domain whitelist data
   * Format: length-prefixed strings
   */
  buildDomainWhitelist(domains: string[]): Uint8Array {
    const parts: Buffer[] = [];
    
    for (const domain of domains) {
      const domainBytes = Buffer.from(domain, "utf-8");
      const lengthByte = Buffer.alloc(1);
      lengthByte[0] = domainBytes.length;
      parts.push(lengthByte, domainBytes);
    }

    return new Uint8Array(Buffer.concat(parts));
  }

  // ============================================================================
  // Configuration Presets
  // ============================================================================

  /**
   * Get a conservative policy configuration preset
   */
  getConservativePreset(): Partial<AgentPolicyConfig> {
    return {
      spendLimit: new BN(100_000_000), // 100 USDC
      txLimit: new BN(10_000_000),     // 10 USDC
      privacyLevel: 0, // Public
      whitelistMode: 0, // Off
      whitelistData: new Uint8Array(),
    };
  }

  /**
   * Get a moderate policy configuration preset
   */
  getModeratePreset(): Partial<AgentPolicyConfig> {
    return {
      spendLimit: new BN(1_000_000_000), // 1000 USDC
      txLimit: new BN(100_000_000),      // 100 USDC
      privacyLevel: 1, // Semi-Private
      whitelistMode: 0, // Off
      whitelistData: new Uint8Array(),
    };
  }

  /**
   * Get a permissive policy configuration preset
   */
  getPermissivePreset(): Partial<AgentPolicyConfig> {
    return {
      spendLimit: new BN(10_000_000_000), // 10000 USDC
      txLimit: new BN(1_000_000_000),     // 1000 USDC
      privacyLevel: 1, // Confidential
      whitelistMode: 0, // Off
      whitelistData: new Uint8Array(),
    };
  }
}
